<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:str="http://exslt.org/strings" extension-element-prefixes="str">
<xsl:template match="/">
<html>
  <head>
    <style  TYPE="text/css">
      
      tr.header
      {      
        background: #96E066;
        font-weight: bold;
      }

      td.tablebg_even
      {
        background: #ededed;
      }

      td.tablebg_odd
      {
        background: #dedede;
      }

      body
      {
        padding: 10px;
        border: #e7e7e7 1px solid;
        background: #ffffff;
        color: black;
        font-size: 13px;
      }

      pre.passed,pre.failed,pre.skipped{
      
        margin: 5px 2px 9px 2px;
        padding: 10px 10px 10px 8px;
            
      }

      pre.passed
      {
        border: #e7e7e7 1px solid;
        background: #f1f1f1;
        color: black;
      }

      pre.failed
      {
        border: #b70707 1px solid;
        background: #a11010;
        color: black;
      }

      pre.skipped
      {
        border: #b7b7b7 1px solid;
        background: #c1c1c1;
        color: #818181;
      }

      td.missing
      {
        background: #a11010;
        color: #ffffff;
      }
    </style>
  </head>
  <body>
    <h2>Documentation</h2>
    <xsl:apply-templates/>
  </body>
</html>
</xsl:template>

<xsl:template match="feature">

  <!-- implements following features, e.g. method name, attribute reader, attribute writer or both when attribute accessor -->
  <xsl:for-each select="str:split(@name,';')">
    <b><xsl:value-of select="."/></b><br />
  </xsl:for-each>
  <br />

  <small>

    <!-- method: call example using parameters -->
    <xsl:if test="@type='method'">
    
      object.<xsl:value-of select="@name" />

      <xsl:choose>

        <xsl:when test="count(arguments/argument)=0">()</xsl:when>
        
        <xsl:when test="count(arguments/argument)>0">
          (      
            <!-- collect arguments for example -->
            <xsl:for-each select="arguments/argument">

              <xsl:if test="@optional='true'"><xsl:text>[</xsl:text></xsl:if>                     
              <xsl:value-of select="@name"/>
              <xsl:if test="@optional='true'"><xsl:text>]</xsl:text></xsl:if> 

              <xsl:if test="position()!=last()">
                <xsl:text>, </xsl:text>
              </xsl:if>
            </xsl:for-each>
          )
        </xsl:when>
                  
      </xsl:choose>

      <!-- describe block usage --> 
      <xsl:if test="count(arguments/block)>0">
        <xsl:text>{ </xsl:text>
        <!-- TODO: block arguments -->
        <xsl:value-of select="arguments/block/@name" />
        <xsl:text> }</xsl:text>
      </xsl:if>
      <br />
    </xsl:if>

    <!-- attr_reader/attr_accessor: call example -->
    <xsl:if test="@type='reader' or @type='accessor'">
      return_value = object.<xsl:value-of select="str:split(@name,';')[1]" /><br />
    </xsl:if>

    <!-- attr_writer/attr_accessor: call example -->
    <xsl:if test="@type='writer' or @type='accessor'">
      <!-- TODO: argument name from arguments array -->
      object.<xsl:value-of select="str:split(@name,';')[1]" /> = ( value )<br />
    </xsl:if>

  </small>
  <br />

  <xsl:apply-templates select="arguments" />

  <xsl:apply-templates select="returns" />

  <xsl:apply-templates select="exceptions" />
  
  <xsl:apply-templates select="info" />
  

</xsl:template>

<xsl:template match="exceptions">

  <!-- exceptions -->
  <b>Exceptions</b>

  <table width="100%" align="center" cellpadding="2" cellspacing="1" border="0">
  <tr class="header">
    <td>Type</td>
    <td>Description</td>
  </tr>

  <xsl:for-each select="type">
    <tr valign="top">
      <td><xsl:value-of select="@name"/></td>
      <td><xsl:for-each select="str:split(description,'\n')">
        <xsl:value-of select="text()" /><br />
      </xsl:for-each>
      </td>
    </tr>
  </xsl:for-each>

  </table>
  <br />

</xsl:template>

<xsl:template match="tests">

  <!-- examples -->
  <b>Examples</b>
  <br />

  <xsl:for-each select="scenario">

    <!-- description (splitted with '\n') -->
    <small>description:
    <xsl:for-each select="str:split(description,'\n')">
      <xsl:value-of select="text()" /><br />
    </xsl:for-each>
    </small>
    <xsl:value-of select="@name"/>
    <xsl:element name="pre">
      <xsl:attribute name="class">
        <xsl:value-of select="@status"/>
      </xsl:attribute>
      <xsl:text># scenario </xsl:text><xsl:value-of select="@status" /><br />
      <xsl:for-each select="str:split(example,'\n')">
        <xsl:value-of select="text()" /><br />
      </xsl:for-each><br />
    </xsl:element>                        

  </xsl:for-each>

</xsl:template>


<xsl:template match="argument[position() mod 2 = 1]">

  <!-- odd -->
  <xsl:variable name="argument_name" select="@name" />
  <xsl:variable name="argument_types" select="count(type)" />
    
  <xsl:for-each select="type">

    <tr valign="top" class="tablebg_odd">
    
      <xsl:if test="position()=1">
        <td rowspan="{$argument_types}" class="tablebg_odd"><xsl:value-of select="$argument_name" /></td>
      </xsl:if>
      
      <td class="tablebg_odd">
        <xsl:value-of select="@name"/>
      </td>
      
      <td class="tablebg_odd">
        <xsl:for-each select="str:split(description,'\n')"><xsl:value-of select="text()" /><br /></xsl:for-each>
      </td>
      
      <td class="tablebg_odd"><xsl:value-of select="example"/></td>
      
      <td class="tablebg_odd"><xsl:value-of select="default"/></td>

    </tr>  
    
  </xsl:for-each>
  
</xsl:template>

<xsl:template match="argument">

  <!-- even -->

  <xsl:variable name="argument_name" select="@name" />
  <xsl:variable name="argument_types" select="count(type)" />
    
  <xsl:for-each select="type">

    <tr valign="top" class="tablebg_even">
    
      <xsl:if test="position()=1">
        <td rowspan="{$argument_types}" class="tablebg_even"><xsl:value-of select="$argument_name" /></td>
      </xsl:if>
      
      <td class="tablebg_even">
        <xsl:value-of select="@name"/>
      </td>
      
      <td class="tablebg_even">
        <xsl:for-each select="str:split(description,'\n')"><xsl:value-of select="text()" /><br /></xsl:for-each>
      </td>
      
      <td class="tablebg_even"><xsl:value-of select="example"/></td>
      
      <td class="tablebg_even"><xsl:value-of select="default"/></td>

    </tr>  
    
  </xsl:for-each>

</xsl:template>


<xsl:template match="arguments">

  <b>Arguments</b><br />
  <table width="100%" align="center" cellpadding="2" cellspacing="1" border="0">
  <tr class="header">
    <td>Name</td>
    <td>Type</td>
    <td>Description</td>
    <td>Example</td>
    <td>Default</td>
  </tr>
  
  <xsl:apply-templates />
  


<!--    
  <xsl:for-each select="argument">

    <tr valign="top">
    <td rowspan="{count(type)+1}" class="tablebg{arguments/argument[position()] mod 2}">
      <xsl:value-of select="@name" />
      <xsl:value-of select="arguments/argument/preceding-sibling::node[position()]" />
    </td>
    
    <xsl:for-each select="type">
      <td class="tablebg{position() mod 2}"><xsl:value-of select="@name"/></td>
      <td class="tablebg{position() mod 2}">
      <xsl:for-each select="str:split(description,'\n')">
        <xsl:value-of select="text()" /><br />
      </xsl:for-each>
      </td>
      <td class="tablebg{arguments/argument[position()] mod 2}"><xsl:value-of select="example"/></td>
      <td class="tablebg{arguments/argument[position()] mod 2}"><xsl:value-of select="default"/></td>

      <xsl:if test="position()!=1">
      </tr><tr>

      </xsl:if>
    </xsl:for-each>
    </tr>
    
  </xsl:for-each>
-->

  <!-- show error message if argument are not described -->
  <xsl:if test="count(argument)!=@count">
    <tr>
    <td colspan="5" class="missing">
      Incomplete documentation: only <xsl:value-of select="count(argument)" />  of <xsl:value-of select="@count" /> arguments documented
    </td>
    </tr>
  </xsl:if>

  </table>
  <br />

</xsl:template>

<xsl:template match="returns">

    <!-- show return value types table if feature type is method, reader or accessor -->
    <!--<xsl:if test="@type='reader' or @type='accessor' or @type='method'">
-->
      <!-- return values -->
      <b>Returns</b>
      <table width="100%" align="center" cellpadding="2" cellspacing="1" border="0">
      <tr class="header">
        <td>Type</td>
        <td>Description</td>
        <td>Example</td>
      </tr>

      <!-- show error message if no return values defined -->
      <xsl:if test="count(type)=0">
        <tr>
        <td colspan="3" class="missing">Incomplete documentation: No return value type(s) defined for method, attribute reader or attribute accessor</td>
        </tr>
      </xsl:if>
  <!--
      <xsl:if test="count(exceptions/type)>0">
        <xsl:for-each select="returns/type">
          <tr valign="top">
            <td><xsl:value-of select="@name"/></td>
            <td><xsl:for-each select="str:split(description,'\n')" name="value">
              <xsl:value-of select="text()" /><br />
            </xsl:for-each>
            </td>
            <td><xsl:value-of select="example"/></td>
          </tr>
        </xsl:for-each>
      </xsl:if>
  </xsl:if>
  -->
    </table>
    <br />

</xsl:template>


<xsl:template match="description">

  <!-- display feature description (split lines with '\n') -->
  <xsl:for-each select="str:split(text(),'\n')">
      <xsl:value-of select="." /><br />
  </xsl:for-each>
  <br />

</xsl:template>

<xsl:template match="info">

  <!-- display feature description (split lines with '\n') 
  -->
  <xsl:for-each select="str:split(text(),'\n')">
      <xsl:value-of select="." /><br />
  </xsl:for-each>
  <br />

</xsl:template>

</xsl:stylesheet>
