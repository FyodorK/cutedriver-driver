
module TDriverVerify   

	# Verifies that the block given to this method evaluates without throwing any exceptions. Verification is synchronized with all connected suts.
	# If this method is called for a sut, synchronization is only done with that sut.
	#
	# === params
	# timeout:: (optional) Integer defining the amount of seconds during which the verification must pass.
	# message:: (optional) A String that is displayed as additional information if the verification fails.
	# === returns
	# nil
	# === raises
	# ArgumentError:: message was not a String or timeout an integer, or no block was given.
	# VerificationError:: The verification failed.
	def verify( timeout = nil, message = nil, &block )

		logging_enabled = MobyUtil::Logger.instance.enabled
		verify_caller = caller(1).first.to_s
		begin

			MobyUtil::Logger.instance.enabled = false
			Kernel::raise ArgumentError.new("No block was given.") unless block_given?
			Kernel::raise ArgumentError.new("Argument timeout was not an Integer.") unless timeout.nil? or timeout.kind_of?(Integer)    
			Kernel::raise ArgumentError.new("Argument message was not a String.") unless message.nil? or message.kind_of?(String)

			# Set the object creation timeout temporarily to the verification timeout if it is larger
			original_sync_timeout = nil
			if !timeout.nil? and (timeout.to_i < MobyBase::TestObjectFactory.instance.timeout)
				original_sync_timeout = MobyBase::TestObjectFactory.instance.timeout
				MobyBase::TestObjectFactory.instance.timeout=(timeout.to_i)
			end

			timeout_time = Time.new + (timeout.nil? ? 0 : timeout.to_i)
			timeout_cycle_seconds = 0.5
		      
			loop do

				begin # catch errors thrown in the provided block
		    
					yield        
					# no error => verification ok
					break
		      
				rescue Exception => e
		    
					source_contents = ""
					error_msg = ""
					if Time.new > timeout_time
				
						error_msg = "Verification at #{verify_caller} failed\n"
				
						begin
							source_contents = find_source(verify_caller)  						
						rescue Exception
							# failed to load line from file, do nothing
							MobyUtil::Logger.instance.enabled = logging_enabled
							MobyUtil::Logger.instance.log "behaviour" , "WARNING;Failed to load source line: #{e.backtrace.inspect}.;#{self.kind_of?(MobyBase::SUT) ? self.id.to_s + ';sut' : ';'};{};verify;"
						end
				
						if !source_contents.empty?
							error_msg << source_contents
						end
						error_msg << "\nNested exception:" << e.message << "\n"
						Kernel::raise MobyBase::VerificationError.new(error_msg)

					end
				   
				end
			  
				sleep timeout_cycle_seconds
		    
				if self.kind_of? MobyBase::SUT
					self.refresh
				else
					#refresh all connected suts          
					MobyBase::SUTFactory.instance.connected_suts.each do |sut_id, sut_attributes| 
						sut_attributes[:sut].refresh if sut_attributes[:is_connected]
					end    
				end

		
			end # do

		rescue Exception => e
			MobyUtil::Logger.instance.enabled = logging_enabled
			MobyUtil::Logger.instance.log "behaviour" , "FAIL;Verification #{message.nil? ? '' : '\"' << message << '\" '}failed: #{e.to_s}#{timeout.nil? ? '' : ' using timeout ' + timeout.to_s}.;#{self.kind_of?(MobyBase::SUT) ? self.id.to_s + ';sut' : ';'};{};verify;"
			Kernel::raise e
		ensure
			MobyBase::TestObjectFactory.instance.timeout=(original_sync_timeout) unless original_sync_timeout.nil?
		end
		MobyUtil::Logger.instance.enabled = logging_enabled
		MobyUtil::Logger.instance.log "behaviour" , "PASS;Verification #{message.nil? ? '' : '\"' << message << '\" '}at #{verify_caller} was successful#{timeout.nil? ? '' : ' using timeout ' + timeout.to_s}.;#{self.kind_of?(MobyBase::SUT) ? self.id.to_s + ';sut' : ';'};{};verify;"
		return nil

	end

	# Verifies that the block given to this method throws an exception while being evaluated. Verification is synchronized with all connected suts.
	# If this method is called for a sut, synchronization is only done with that sut.
	#
	# === params
	# timeout:: (optional) Integer defining the amount of seconds during which the verification must pass.
	# message:: (optional) A String that is displayed as additional information if the verification fails.
	# === returns
	# nil
	# === raises
	# ArgumentError:: message was not a String or timeout an integer, or no block was given.
	# VerificationError:: The verification failed.
	def verify_not( timeout = nil, message = nil, &block )

		logging_enabled = MobyUtil::Logger.instance.enabled
		verify_caller = caller(1).first.to_s

		begin

			MobyUtil::Logger.instance.enabled = false

			Kernel::raise ArgumentError.new("No block was given.") unless block_given?
			Kernel::raise ArgumentError.new("Argument timeout was not an Integer.") unless timeout.nil? or timeout.kind_of?( Integer )    
			Kernel::raise ArgumentError.new("Argument message was not a String.") unless message.nil? or message.kind_of?( String )

			# Set the object creation timeout temporarily to the verification timeout if it is larger
			original_sync_timeout = nil

			if !timeout.nil? and ( timeout.to_i < MobyBase::TestObjectFactory.instance.timeout )

				original_sync_timeout = MobyBase::TestObjectFactory.instance.timeout
				MobyBase::TestObjectFactory.instance.timeout=(timeout.to_i)

			end
	
			timeout_time = Time.new + (timeout.nil? ? 0 : timeout.to_i)
			timeout_cycle_seconds = 0.5

			loop do

				artificial_exception_raised = false

				begin # catch errors thrown in the provided block
		  
					yield  
					artificial_exception_raised = true
					Kernel::raise "test"

				rescue Exception => e
			
					source_contents = ""
					error_msg = ""

					# an error was encountered => verification ok			
					break unless artificial_exception_raised
			
					if Time.new > timeout_time
						error_msg = "Verification at #{ verify_caller } failed\n"
						source_contents = find_source( verify_caller )
						error_msg << source_contents if !source_contents.empty?
						Kernel::raise MobyBase::VerificationError.new( error_msg )		    
					end
		
					sleep timeout_cycle_seconds
		  
					if self.kind_of? MobyBase::SUT

						self.refresh

					else
		    
						#refresh all connected suts          
						MobyBase::SUTFactory.instance.connected_suts.each do | sut_id, sut_attributes | 
							sut_attributes[:sut].refresh if sut_attributes[ :is_connected ]
						end    
		    
					end
		  
				end

			end # do

		rescue Exception => e

			MobyUtil::Logger.instance.enabled = logging_enabled
			MobyUtil::Logger.instance.log "behaviour" , "FAIL;Verification #{message.nil? ? '' : '\"' << message << '\" '}failed: #{e.to_s}#{timeout.nil? ? '' : ' using timeout ' + timeout.to_s}.;#{self.kind_of?(MobyBase::SUT) ? self.id.to_s + ';sut' : ';'};{};verify_not;"
			Kernel::raise e
		ensure
			MobyBase::TestObjectFactory.instance.timeout=(original_sync_timeout) unless original_sync_timeout.nil?
		end  

		MobyUtil::Logger.instance.enabled = logging_enabled
		MobyUtil::Logger.instance.log "behaviour" , "PASS;Verification #{message.nil? ? '' : '\"' << message << '\" '}at #{verify_caller} was successful#{timeout.nil? ? '' : ' using timeout ' + timeout.to_s}.;#{self.kind_of?(MobyBase::SUT) ? self.id.to_s + ';sut' : ';'};{};verify_not;"
		return nil

	end

	# Verifies that the block given to this method evaluates to true. Verification is synchronized with all connected suts.
	# If this method is called for a sut, synchronization is only done with that sut.
	#
	# === params
	# timeout:: (optional) Integer defining the amount of seconds during which the verification must pass.
	# message:: (optional) A String that is displayed as additional information if the verification fails.
	# === returns
	# nil
	# === raises
	# ArgumentError:: message was not a String or timeout an integer, or no block was given.
	# VerificationError:: The verification failed.   
	# RuntimeError:: An unexpected error was encountered during verification. 
	def verify_true( timeout = nil, message = nil, &block )

		logging_enabled = MobyUtil::Logger.instance.enabled

		verify_caller = caller(1).first.to_s

		begin

			MobyUtil::Logger.instance.enabled = false
			Kernel::raise ArgumentError.new("No block was given.") unless block_given?
			Kernel::raise ArgumentError.new("Argument timeout was not an Integer.") unless timeout.nil? or timeout.kind_of?(Integer)    
			Kernel::raise ArgumentError.new("Argument message was not a String.") unless message.nil? or message.kind_of?(String)

			# Set the object creation timeout temporarily to the verification timeout if it is larger
			original_sync_timeout = nil

			if !timeout.nil? and (timeout.to_i < MobyBase::TestObjectFactory.instance.timeout)
				original_sync_timeout = MobyBase::TestObjectFactory.instance.timeout
				MobyBase::TestObjectFactory.instance.timeout=(timeout.to_i)
			end

			timeout_time = Time.new + (timeout.nil? ? 0 : timeout.to_i)
			timeout_cycle_seconds = 0.5

			loop do

				begin # catch errors thrown due to verification results


					begin # catch errors thrown in the provided block
						result = yield
					rescue Exception => e
						error_msg = "Verification at #{verify_caller} failed as an exception was thrown when the verification block was executed."
						error_msg << find_source(verify_caller)
						error_msg << "\nDetails: " << message unless message.nil?
						error_msg << "\n" << e.inspect
						raise MobyBase::VerificationError.new(error_msg)
					end      

					error_msg = "Verification at #{verify_caller} failed."
					error_msg << find_source(verify_caller)
					error_msg << "\nThe block did not return true. It returned: " << result.inspect
					error_msg << "\nDetails: " << message unless message.nil?
					raise MobyBase::VerificationError.new(error_msg) unless result == true

					# break loop if no exceptions thrown
					break

				rescue MobyBase::VerificationError => ve

					# refresh and retry unless timeout reached

					if Time.new > timeout_time
						Kernel::raise ve 
					end

					sleep timeout_cycle_seconds

					if self.kind_of? MobyBase::SUT
						self.refresh
					else

						#refresh all connected suts          
						MobyBase::SUTFactory.instance.connected_suts.each do |sut_id, sut_attributes| 
							sut_attributes[:sut].refresh if sut_attributes[:is_connected]
						end         

					end

				rescue Exception => e

					MobyUtil::Logger.instance.enabled = logging_enabled
					# an unexpected error has occurred
					Kernel::raise RuntimeError.new("An unexpected error was encountered during verification:\n" << e.inspect )        

				end # begin, catch any VerificationErrors  

			end # do    

		rescue Exception => e

			MobyUtil::Logger.instance.enabled = logging_enabled
			MobyUtil::Logger.instance.log "behaviour" , "FAIL;Verification #{message.nil? ? '' : '\"' << message << '\" '}failed:#{e.to_s}.\n#{timeout.nil? ? '' : ' using timeout ' + timeout.to_s}.;#{self.kind_of?(MobyBase::SUT) ? self.id.to_s + ';sut' : ';'};{};verify_true;"
			Kernel::raise e

		ensure

			MobyBase::TestObjectFactory.instance.timeout=(original_sync_timeout) unless original_sync_timeout.nil?
		end  

		MobyUtil::Logger.instance.enabled = logging_enabled
		MobyUtil::Logger.instance.log "behaviour" , "PASS;Verification #{message.nil? ? '' : '\"' << message << '\" '}at #{verify_caller} was successful#{timeout.nil? ? '' : ' using timeout ' + timeout.to_s}.;#{self.kind_of?(MobyBase::SUT) ? self.id.to_s + ';sut' : ';'};{};verify_true;"

		nil

	end

	# Verifies that the block given to this method evaluates to false. Verification is synchronized with all connected suts.
	# If this method is called for a sut, synchronization is only done with that sut.
	#
	# === params
	# timeout:: (optional) Integer defining the amount of seconds during which the verification must pass.
	# message:: (optional) A String that is displayed as additional information if the verification fails.
	# === returns
	# nil
	# === raises
	# ArgumentError:: message was not a String or timeout an integer, or no block was given.
	# VerificationError:: The verification failed.   
	# RuntimeError:: An unexpected error was encountered during verification.
	def verify_false( timeout = nil, message = nil, &block )

		logging_enabled = MobyUtil::Logger.instance.enabled
		verify_caller = caller(1).first.to_s

		begin
			MobyUtil::Logger.instance.enabled = false

			Kernel::raise ArgumentError.new("No block was given.") unless block_given?
			Kernel::raise ArgumentError.new("Argument timeout was not an Integer.") unless timeout.nil? or timeout.kind_of?(Integer)    
			Kernel::raise ArgumentError.new("Argument message was not a String.") unless message.nil? or message.kind_of?(String)

			# Set the object creation timeout temporarily to the verification timeout if it is larger
			original_sync_timeout = nil

			if !timeout.nil? and (timeout.to_i < MobyBase::TestObjectFactory.instance.timeout)
				original_sync_timeout = MobyBase::TestObjectFactory.instance.timeout
				MobyBase::TestObjectFactory.instance.timeout=(timeout.to_i)
			end

			timeout_time = Time.new + ( timeout.nil? ? 0 : timeout.to_i )
			timeout_cycle_seconds = 0.5

			loop do

				begin # catch errors thrown due to verification results

					begin # catch errors thrown in the provided block
						result = yield
					rescue Exception => e
						error_msg = "Verification at #{verify_caller} failed as an exception was thrown when the verification block was executed."
						error_msg << find_source(verify_caller)
						error_msg << "\nDetails: " << message unless message.nil?
						error_msg << "\n" << e.inspect
						raise MobyBase::VerificationError.new(error_msg)
					end      

					error_msg = "Verification at #{verify_caller} failed:"
					error_msg << find_source(verify_caller)
					error_msg << "The block did not return false. It returned: " << result.inspect
					error_msg << "\nDetails: " << message unless message.nil?
					raise MobyBase::VerificationError.new(error_msg) unless result == false

					# break loop if no exceptions thrown
					break

				rescue MobyBase::VerificationError => ve

					# refresh and retry unless timeout reached

					if Time.new > timeout_time 
						Kernel::raise ve 
					end

					sleep timeout_cycle_seconds

					if self.kind_of? MobyBase::SUT
						self.refresh
					else

						#refresh all connected suts          
						MobyBase::SUTFactory.instance.connected_suts.each do |sut_id, sut_attributes| 
							sut_attributes[:sut].refresh if sut_attributes[:is_connected]
						end         

					end

				rescue Exception => e

					# an unexpected error has occurred
					MobyUtil::Logger.instance.enabled = logging_enabled
					Kernel::raise RuntimeError.new("An unexpected error was encountered during verification:\n" << e.inspect )        

				end # begin, catch any VerificationErrors  

			end # do  

		rescue Exception => e

			MobyUtil::Logger.instance.enabled = logging_enabled
			MobyUtil::Logger.instance.log "behaviour" , "FAIL;Verification #{message.nil? ? '' : '\"' << message << '\" '}failed:#{e.to_s}.\n #{timeout.nil? ? '' : ' using timeout ' + timeout.to_s}.;#{self.kind_of?(MobyBase::SUT) ? self.id.to_s + ';sut' : ';'};{};verify_false;"
			Kernel::raise e

		ensure

			MobyBase::TestObjectFactory.instance.timeout=(original_sync_timeout) unless original_sync_timeout.nil?

		end

		MobyUtil::Logger.instance.enabled = logging_enabled
		MobyUtil::Logger.instance.log "behaviour" , "PASS;Verification #{message.nil? ? '' : '\"' << message << '\" '}at #{verify_caller} was successful#{timeout.nil? ? '' : ' using timeout ' + timeout.to_s}.;#{self.kind_of?(MobyBase::SUT) ? self.id.to_s + ';sut' : ';'};{};verify_false;"
		nil

	end

	# Verifies that the block given to this method evaluates to the expected value. Verification is synchronized with all connected suts.
	# If this method is called for a sut, synchronization is only done with that sut.
	#
	# === params
	# expected:: Expected result value of the block
	# timeout:: (optional) Integer defining the amount of seconds during which the verification must pass.
	# message:: (optional) A String that is displayed as additional information if the verification fails.
	# === returns
	# nil
	# === raises
	# ArgumentError:: message was not a String or timeout an integer, or no block was given.
	# VerificationError:: The verification failed.   
	# RuntimeError:: An unexpected error was encountered during verification.
	def verify_equal( expected, timeout = nil, message = nil, &block )

		logging_enabled = MobyUtil::Logger.instance.enabled
		verify_caller = caller(1).first.to_s

		begin

			MobyUtil::Logger.instance.enabled = false

			Kernel::raise ArgumentError.new("No block was given.") unless block_given?
			Kernel::raise ArgumentError.new("Argument timeout was not an Integer.") unless timeout.nil? or timeout.kind_of?(Integer)    
			Kernel::raise ArgumentError.new("Argument message was not a String.") unless message.nil? or message.kind_of?(String)

			# Set the object creation timeout temporarily to the verification timeout if it is larger
			original_sync_timeout = nil

			if !timeout.nil? and (timeout.to_i < MobyBase::TestObjectFactory.instance.timeout)
				original_sync_timeout = MobyBase::TestObjectFactory.instance.timeout
				MobyBase::TestObjectFactory.instance.timeout=(timeout.to_i)
			end

			timeout_time = Time.new + (timeout.nil? ? 0 : timeout.to_i)
			timeout_cycle_seconds = 0.5

			loop do

				begin # catch errors thrown due to verification results

					begin # catch errors thrown in the provided block
						result = yield
					rescue Exception => e            
						error_msg = "Verification at #{verify_caller} failed as an exception was thrown when the verification block was executed."
						error_msg << find_source(verify_caller)
						error_msg << "\nDetails: " << message unless message.nil?
						error_msg << "\n" << e.inspect
						raise MobyBase::VerificationError.new(error_msg)
					end      

					error_msg = "Verification at #{verify_caller} failed:"
					error_msg << find_source(verify_caller)
					error_msg << "The block did not return #{expected.inspect}. It returned: " << result.inspect
					error_msg << "\nDetails: " << message unless message.nil?
					raise MobyBase::VerificationError.new(error_msg) unless result == expected

					# break loop if no exceptions thrown
					break

				rescue MobyBase::VerificationError => ve

					# refresh and retry unless timeout reached

					if Time.new > timeout_time            
						Kernel::raise ve 
					end

					sleep timeout_cycle_seconds

					if self.kind_of? MobyBase::SUT

						self.refresh

					else

						#refresh all connected suts          
						MobyBase::SUTFactory.instance.connected_suts.each do |sut_id, sut_attributes| 
							sut_attributes[:sut].refresh if sut_attributes[:is_connected]
						end         

					end

				rescue Exception => e

					# an unexpected error has occurred
					Kernel::raise RuntimeError.new("An unexpected error was encountered during verification:\n" << e.inspect )        

				end # begin, catch any VerificationErrors  

			end # do

		rescue Exception => e

			MobyUtil::Logger.instance.enabled = logging_enabled
			MobyUtil::Logger.instance.log "behaviour" , "FAIL;Verification #{message.nil? ? '' : '\"' << message << '\" '}failed:#{e.to_s}.\n#{timeout.nil? ? '' : ' using timeout ' + timeout.to_s}.;#{self.kind_of?(MobyBase::SUT) ? self.id.to_s + ';sut' : ';'};{};verify_equal;" << expected.to_s
			Kernel::raise e
		ensure
			MobyBase::TestObjectFactory.instance.timeout=(original_sync_timeout) unless original_sync_timeout.nil?
		end

		MobyUtil::Logger.instance.enabled = logging_enabled
		MobyUtil::Logger.instance.log "behaviour" , "PASS;Verification #{message.nil? ? '' : '\"' << message << '\" '}at #{verify_caller} was successful#{timeout.nil? ? '' : ' using timeout ' + timeout.to_s}.;#{self.kind_of?(MobyBase::SUT) ? self.id.to_s + ';sut' : ';'};{};verify_equal;" << expected.to_s

		nil

	end


	private  

	# Searches for the given source file for a line
	#
	# === params
	# from_file:: String defining the file to load. If at_line is nil, this argument can also contain a path and line number separated by : (eg. some_dir/some_file.rb:123).
	# at_line:: (optional) Integer, number of the line (first line is 1).
	# === returns
	# String:: Contents of the line
	# === throws
	# RuntimeError:: from_file is not correctly formed, the file cannot be loaded or the line cannot be found.
	def find_source(backtrace)

		ret_str = "\n"

		begin

			call_stack = backtrace.to_s.split(':')
			#puts "call_stack:" << backtrace.to_s
	
			line_number = 0
			if (call_stack.size() == 2) 
				line_number = call_stack[1].to_i
		
			else
				line_number = call_stack[call_stack.size()-2].to_i
			end		
			#puts "line number: " << line_number.to_s
	
			file_path = ""
			if (call_stack.size() == 2)
				file_path = call_stack[0]
			else
				(call_stack.size()-2).times do |index|
					file_path << call_stack[index].to_s << ":"
				end
				file_path.slice!(file_path.size()-1) # remove the trailing colon
			end
			#puts "file path: " << file_path.to_s
			
			lines_to_read = line_number >= 2 ? 3 : line_number
			#puts "lines to read: " << lines_to_read.to_s
				
			start_line = line_number #- (lines_to_read <= 1 ? 0 : 1)
			#puts "start line:" << start_line.to_s

			File.open(File.expand_path(file_path.to_s), "r") { |source| 

				lines = source.readlines
				Kernel::raise RuntimeError.new("Only \"#{lines.size.to_s}\" lines exist in the source file.")if start_line >= lines.size

		lines_to_read = (lines.size - start_line + 1) < 3 ? (lines.size - start_line + 1) : lines_to_read

				# the array is zero based, first line is at position 0
				lines_to_read.times do |index|
					if (line_number == (start_line + index))
						ret_str << "=> "
					else
						ret_str << "   "
					end
					ret_str << lines[start_line + index - 1]
				end

			}    

		rescue Exception => e

			#puts "exception:" << e.inspect
			ret_str << "Unable to load source lines.\n" << e.inspect

		end  

		return ret_str

	end

	# Searches the backtrace line that is next from verify itself
	#
	# === params
	# backtrace:: Array, exception backtrace
	# === returns
	# Integer:: Index of bactrace item
	# === throws 
	# RuntimeError:: backtrace is nil or empty or correct line not found.
	def find_line(backtrace)

		Kernel::raise RuntimeError.new("Backtrace was nil") if backtrace.nil?
		Kernel::raise RuntimeError.new("Backtrace is empty") if backtrace.size <= 0

		moby_found = false

		backtrace.size.times do |index|
			if (backtrace[index].include?("/util/lib/verify.rb:")) 
				moby_found = true 
			else
				if (moby_found)
					return index
				end
			end
		end
		Kernel::raise RuntimeError.new("Correct line not found from backtrace.")
	end

	def parse_caller(at)
		if /^(.+?):(\d+)(?::in `(.*)')?/ =~ at
			file = Regexp.last_match[1]
			line = Regexp.last_match[2].to_i
			method = Regexp.last_match[3]
			[file, line, method]
		end
	end

end
